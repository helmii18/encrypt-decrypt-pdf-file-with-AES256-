import numpy as np
from base64 import b64encode, b64decode
import datetime
import base64

roundConstant = np.array([
    [0x01, 0x00, 0x00, 0x00],
    [0x02, 0x00, 0x00, 0x00],
    [0x04, 0x00, 0x00, 0x00],
    [0x08, 0x00, 0x00, 0x00],
    [0x10, 0x00, 0x00, 0x00],
    [0x20, 0x00, 0x00, 0x00],
    [0x40, 0x00, 0x00, 0x00],
    [0x80, 0x00, 0x00, 0x00],
    [0x1b, 0x00, 0x00, 0x00],
    [0x36, 0x00, 0x00, 0x00],
])

roundConstant_8 = np.array([
    [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
])


# Substitution Box: Encryption
s_box = np.array([
    [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
    [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
    [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
    [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
    [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
    [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
    [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
    [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
    [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
    [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
    [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
    [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
    [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
    [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
    [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
    [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16],
])


# Substitution Box: Decryption
invs_box = np.array([
    [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
    [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
    [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
    [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
    [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
    [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
    [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
    [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
    [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
    [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
    [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
    [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
    [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
    [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
    [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
    [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d],
])


# Rijndael Galois Field: Encryption
encryptMDS = np.array([
    [0x02, 0x03, 0x01, 0x01],
    [0x01, 0x02, 0x03, 0x01],
    [0x01, 0x01, 0x02, 0x03],
    [0x03, 0x01, 0x01, 0x02],
])


# Rijndael Galois Field: Encryption 8*8
encryptMDS_8 = np.array([
    [0x02, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01],
    [0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02],
    [0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01],
    [0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03],
    [0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01],
    [0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x01],
    [0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x01, 0x01],
    [0x01, 0x02, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01],
])


# Rijndael Galois Field: Decryption
decryptMDS = np.array([
    [0x0e, 0x0b, 0x0d, 0x09],
    [0x09, 0x0e, 0x0b, 0x0d],
    [0x0d, 0x09, 0x0e, 0x0b],
    [0x0b, 0x0d, 0x09, 0x0e],
])

# Rijndael Galois Field: Decryption 8*8
decryptMDS_8 = np.array([
    [0x0e, 0x01, 0x09, 0x01, 0x0d, 0x01, 0x0b, 0x01],
    [0x01, 0x09, 0x01, 0x0d, 0x01, 0x0b, 0x01, 0x0e],
    [0x09, 0x01, 0x0d, 0x01, 0x0b, 0x01, 0x0e, 0x01],
    [0x01, 0x0d, 0x01, 0x0b, 0x01, 0x0e, 0x01, 0x09],
    [0x0d, 0x01, 0x0b, 0x01, 0x0e, 0x01, 0x09, 0x01],
    [0x01, 0x0b, 0x01, 0x0e, 0x01, 0x09, 0x01, 0x0d],
    [0x0b, 0x01, 0x0e, 0x01, 0x09, 0x01, 0x0d, 0x01],
    [0x01, 0x0e, 0x01, 0x09, 0x01, 0x0d, 0x01, 0x0b],
])


# Look UP Table Mix Column:
mc2 = np.array([
    [0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e],
    [0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e],
    [0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e],
    [0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e],
    [0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e],
    [0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe],
    [0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde],
    [0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe],
    [0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05],
    [0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25],
    [0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45],
    [0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65],
    [0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85],
    [0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5],
    [0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5],
    [0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5]
])


mc3 = np.array([
    [0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11],
    [0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21],
    [0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71],
    [0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41],
    [0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1],
    [0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1],
    [0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1],
    [0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81],
    [0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a],
    [0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba],
    [0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea],
    [0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda],
    [0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a],
    [0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a],
    [0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a],
    [0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a]
])


mc9 = np.array([
    [0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77],
    [0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7],
    [0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c],
    [0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc],
    [0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01],
    [0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91],
    [0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a],
    [0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa],
    [0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b],
    [0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b],
    [0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0],
    [0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30],
    [0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed],
    [0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d],
    [0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6],
    [0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46]
])

# 0x0b
mc11 = np.array([
    [0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69],
    [0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9],
    [0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12],
    [0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2],
    [0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f],
    [0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f],
    [0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4],
    [0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54],
    [0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e],
    [0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e],
    [0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5],
    [0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55],
    [0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68],
    [0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8],
    [0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13],
    [0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3]
])


# 0x0d
mc13 = np.array([
    [0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b],
    [0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b],
    [0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0],
    [0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20],
    [0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26],
    [0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6],
    [0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d],
    [0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d],
    [0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91],
    [0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41],
    [0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a],
    [0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa],
    [0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc],
    [0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c],
    [0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47],
    [0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97]
])


# 0x0e
mc14 = np.array([
    [0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a],
    [0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba],
    [0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81],
    [0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61],
    [0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7],
    [0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17],
    [0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c],
    [0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc],
    [0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b],
    [0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb],
    [0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0],
    [0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20],
    [0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6],
    [0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56],
    [0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d],
    [0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d]
])



# Key to Matrix
def keyToHexArray(key, row=4, col=4):
    arr = []
    for i in key:
        arr.append(ord(i))
    arr = np.array(arr)
    arr = arr.reshape(row, col)  # 4*4 matrix
    return arr


# Apply left shift / RotWord
def arrayShift(arr, shift=-1):
    return np.roll(arr, shift)


# S-box on 1D Array
def arraySbox(arr):
    for i in range(0, len(arr)):
        lsb = arr[i] & 0b00001111
        msb = (arr[i] & 0b11110000) >> 4
        arr[i] = s_box[msb, lsb]
    return arr


# Inverse S-box on 1D Array
def arrayInvSbox(arr):
    for i in range(0, len(arr)):
        lsb = arr[i] & 0b00001111
        msb = (arr[i] & 0b11110000) >> 4
        arr[i] = invs_box[msb, lsb]
    return arr


# XOR Operation on [arr1, arr2] or [arr1,arr2,rcon(i)]
def xorArray(arr1, arr2, order=4, rcon=-1):
    xor_arr = []
    if (arr1.shape == arr2.shape and (rcon >= -1 and rcon <= 9)):
        if (rcon == -1):
            for i in range(len(arr1)):
                val = arr1[i] ^ arr2[i]
                xor_arr.append(val)
        else:
            rcon_arr = roundConstant[rcon]
            if (order == 8):
                rcon_arr = roundConstant_8[rcon]
            for i in range(len(arr1)):
                val = arr1[i] ^ arr2[i] ^ rcon_arr[i]
                xor_arr.append(val)
        xor_arr = np.array(xor_arr)
        return xor_arr
    else:
        print('Array must be same dimension numpy OR Rcon: roundconstant must be 0-10')
        print(arr1, arr2, rcon)
        return False


# Xor 2 2D array
def addRoundKey(arr1, arr2):
    return np.bitwise_xor(arr1, arr2)


# Substitution-box on 2D Array
def subBytes(arr, inverse=False):
    for i in arr:
        if (not inverse):
            arraySbox(i)
        else:
            arrayInvSbox(i)
    return arr


# Shift Row on 2D Array
def shiftRow(arr, left=True, order=4):
    shifted_arr = []
    for i in range(0, order):
        if (left):
            x = arrayShift(arr[:, i], -1 * i)  # Left circular shift: Encryption
        else:
            x = arrayShift(arr[:, i], i)  # Right circular shift: Decryption
        shifted_arr.append(x)
    shifted_arr = np.array(shifted_arr)  # Accurate
    return np.transpose(shifted_arr)


# Mix Column
def mixColumn(arr, order=4):
    arr = np.transpose(arr)
    mix_arr = np.zeros((order, order), dtype=int)
    encryptMDS_arr = encryptMDS
    if (order == 8):
        encryptMDS_arr = encryptMDS_8
    for i in range(0, order):
        for j in range(0, order):
            for k in range(0, order):
                if (encryptMDS_arr[i][k] == 1):
                    mix_arr[i][j] ^= arr[k][j]
                lsb = arr[k][j] & 0b00001111
                msb = (arr[k][j] & 0b11110000) >> 4
                if (encryptMDS_arr[i][k] == 2):
                    mix_arr[i][j] ^= mc2[msb, lsb]
                if (encryptMDS_arr[i][k] == 3):
                    mix_arr[i][j] ^= mc3[msb, lsb]
    return np.transpose(mix_arr)


# Inverse Mix Column
def inverseMixColumn(arr, order=4):
    decryptMDS_arr = decryptMDS
    if (order == 8):
        decryptMDS_arr = decryptMDS_8
    arr = np.transpose(arr)
    mix_arr = np.zeros((order, order), dtype=int)
    for i in range(0, order):
        for j in range(0, order):
            for k in range(0, order):
                if (decryptMDS_arr[i][k] == 1):
                    mix_arr[i][j] ^= arr[k][j]
                lsb = arr[k][j] & 0b00001111
                msb = (arr[k][j] & 0b11110000) >> 4
                if (decryptMDS_arr[i][k] == 9):
                    mix_arr[i][j] ^= mc9[msb, lsb]
                if (decryptMDS_arr[i][k] == 11):
                    mix_arr[i][j] ^= mc11[msb, lsb]
                if (decryptMDS_arr[i][k] == 13):
                    mix_arr[i][j] ^= mc13[msb, lsb]
                if (decryptMDS_arr[i][k] == 14):
                    mix_arr[i][j] ^= mc14[msb, lsb]
    return np.transpose(mix_arr)


# Decryption: ecrypted hex to matrix
'''
4*4: 16 box => 128 bits => 32 in hex (representation)
8*8: 64 box => 512 bits => 128 in hex (representation)
'''


def hexToMatrix(data, order=4):
    hexbit = order * order * 2
    if (len(data) == hexbit):
        val = [data[i:i + 2] for i in range(0, len(data), 2)]
        val = [int(x, 16) for x in val]
        arr = np.array(val)
        arr = arr.reshape(order, order)  # 4*4 matrix
        return arr
    else:
        print('length of encrypted data should be 32')

class AES:

    def __init__(self):
        self.ROUND = 14
        self.ROUNDKEY = []

    # Key Scheduling
    def __keySchedule(self, KEY):
        ROW, COL = 8, 4
        EXPANSION = 7
        hexKey = keyToHexArray(KEY, ROW, COL)
        self.ROUNDKEY.append(hexKey)
        for i in range(0, EXPANSION):
            prev_arr = self.ROUNDKEY[-1]
            last_col = prev_arr[ROW - 1]
            shift_col = arrayShift(last_col)
            sbox_col = arraySbox(shift_col)
            col_1 = xorArray(prev_arr[0], sbox_col, i)
            col_2 = xorArray(col_1, prev_arr[1])
            col_3 = xorArray(col_2, prev_arr[2])
            col_4 = xorArray(col_3, prev_arr[3])
            # additional non-linear transformation after the fourth column
            col_5 = xorArray(arraySbox(np.copy(col_4)), prev_arr[4])
            col_6 = xorArray(col_5, prev_arr[5])
            col_7 = xorArray(col_6, prev_arr[6])
            col_8 = xorArray(col_7, prev_arr[7])
            new_arr = np.array([col_1, col_2, col_3, col_4, col_5, col_6, col_7, col_8])
            self.ROUNDKEY.append(new_arr)
        self.__convertRoundKey()

    # Convert 8 4*8 Matrix to 15 4*4 Matrix
    def __convertRoundKey(self):
        self.ROUNDKEY = np.concatenate(self.ROUNDKEY)
        temp = []
        for i in range(self.ROUND + 1):
            temp.append(self.ROUNDKEY[i * 4:i * 4 + 4])
        self.ROUNDKEY = temp

    # Encryption Process
    def __encryptProcess(self, TEXT):
        print(TEXT)
        hexData = keyToHexArray(TEXT)
        print("after convert to hexdata" , hexData)
        cipher_arr = addRoundKey(hexData, self.ROUNDKEY[0])
        print("cipher arr ",cipher_arr)
        for i in range(1, self.ROUND + 1):
            print("\nround " ,i,"\n")
            arr = cipher_arr
            print("cipher arr ", arr)
            arr = subBytes(arr)
            print("after sub bytes",arr)
            arr = shiftRow(arr)
            print("after shift rows",arr)
            if (i != self.ROUND):
                arr = mixColumn(arr)
                # print("after mix columns",arr)
            arr = addRoundKey(arr, self.ROUNDKEY[i])
            cipher_arr = arr
        return cipher_arr

    # Encryption Add Padding
    def __addPadding(self, data):
        bytes = 16
        bits_arr = []
        while (True):
            if (len(data) > bytes):
                bits_arr.append(data[:bytes])
                data = data[bytes:]
            else:
                space = bytes - len(data)
                bits_arr.append(data + chr(space) * space)
                break
        return bits_arr

    # Decryption Process
    def __decryptProcess(self, CIPHER_HEX):
        hexData = hexToMatrix(CIPHER_HEX)
        plain_arr = addRoundKey(hexData, self.ROUNDKEY[-1])
        for i in range(self.ROUND - 1, -1, -1):
            print("\nround ", i, "\n")
            arr = plain_arr
            print("plain arr ", arr)
            arr = shiftRow(arr, left=False)
            print("after inverse of shift rows", arr)
            arr = subBytes(arr, inverse=True)
            print("after inverse of sub bytes", arr)
            arr = addRoundKey(arr, self.ROUNDKEY[i])
            if (i != 0):
                arr = inverseMixColumn(arr)
                print("after inverse mix columns", arr)
            plain_arr = arr
        return plain_arr

    # Decryption Delete Padding
    def __delPadding(self, data):
        verify = data[-1]
        bytes = 16
        if (verify >= 1 and verify <= bytes - 1):
            pad = data[bytes - verify:]
            sameCount = pad.count(verify)
            if (sameCount == verify):
                return data[:bytes - verify]
            return data
        return data

    # Encryption
    def encrypt(self, KEY, TEXT, type='hex'):
        text_arr = self.__addPadding(TEXT)
        print("after add padding",text_arr)
        self.__keySchedule(KEY)
        hex_ecrypt = ''
        for i in text_arr:
            cipher_matrix = self.__encryptProcess(i)
            cipher_text = list(np.array(cipher_matrix).reshape(-1, ))
            for j in cipher_text:
                hex_ecrypt += f'{j:02x}'
        self.ROUNDKEY = []
        # conversion
        if (type == 'b64'):
            return b64encode(bytes.fromhex(hex_ecrypt)).decode()
        if (type == '0b'):
            return f'{int(hex_ecrypt, 16):0>b}'
        if (type == '__all__'):
            return {
                'hex': hex_ecrypt,
                'b64': b64encode(bytes.fromhex(hex_ecrypt)).decode(),
                '0b': bin(int(hex_ecrypt, 16))[2:].zfill(len(hex_ecrypt) * 4)
            }
        return hex_ecrypt

    # Decryption
    def decrypt(self, KEY, CIPHER, type='hex'):
        if type in ['hex', '0b', 'b64']:
            self.__keySchedule(KEY)
            data = ''

            if (type == 'b64'):
                CIPHER = b64decode(CIPHER).hex()
                print("cipher in b64",CIPHER)
            if (type == '0b'):
                CIPHER = hex(int(CIPHER, 2)).replace('0x', '')
                print("cipher in 0b",CIPHER)
            if (len(CIPHER) % 32 == 0 and len(CIPHER) > 0):
                examine = CIPHER
                while (len(examine) != 0):
                    plain_matrix = self.__decryptProcess(examine[:32])
                    plain_arr = list(np.array(plain_matrix).reshape(-1, ))
                    plain_arr = self.__delPadding(plain_arr)
                    for j in plain_arr:
                        data += chr(j)
                    if (len(examine) == 32):
                        examine = ''
                    else:
                        examine = examine[32:]
                self.ROUNDKEY = []
                return data

            else:
                raise Exception(f"Hex: {CIPHER}, should be non-empty multiple of 32bits")

        else:
            raise Exception(f"type := ['hex', '0b', 'b64'] but got '{type}'")


if (__name__ == '__main__'):
    aes256 = AES()
    key = 'Thats my Kung Fu1234567876543210'
    print("***************************************")
    filenameencypt=input("enter file name to encryption ")+".pdf"

    with open(filenameencypt, "rb") as pdf_file:
        encoded = base64.b64encode(pdf_file.read())
        encoded_string=encoded.decode('utf-8')
    stretime = datetime.datetime.now()
    c=(aes256.encrypt(key,encoded_string,'0b'))
    endetime = datetime.datetime.now()
    print("encryption takes ", (endetime - stretime).microseconds * 1000, " milli seconds")
    file_64_decodee10 = base64.b64decode(c)
    file_resultc = open('encryption file.pdf', 'wb')
    file_resultc.write(file_64_decodee10)
    print("encryption done with encryption file")

    print("***************************************")
    filenamedecrypt=input("enter file to decryption")+".pdf"
    with open(filenamedecrypt, "rb") as pdf_file:
        cc = base64.b64encode(pdf_file.read())
    strtimdec = datetime.datetime.now()
    m=aes256.decrypt(key,cc,'0b')
    endetimdec = datetime.datetime.now()
    print("encryption takes ", (endetimdec- strtimdec).microseconds * 1000, " milli seconds")
    file_64_decoded00 = base64.b64decode(m)
    file_result00 = open('decryption file.pdf', 'wb')
    file_result00.write(file_64_decoded00)
    print("***************************************")
    print("encryption done with decryption file")

